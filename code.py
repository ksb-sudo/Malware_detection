import json
import pandas as pd
import numpy as np
import missingno as msno
from sklearn.impute import SimpleImputer
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv('Malware_Classification.csv')

#checking for numerical type values and object type values
num_var=df.select_dtypes(include=[np.number])
obj_var=df.select_dtypes(include=[np.object])

#checking for null values
mask=df.isna()
total=mask.sum()
percent=100*mask.mean()
missing_data=pd.concat([total,percent],axis=1,join='outer',keys=['count missing','percentage_missing'])
missing_data.sort_values(by='percentage_missing',ascending=False,inplace=True)

nullable_columns = df.columns[mask.any()].tolist()
#msno.matrix(df[nullable_columns].sample(10))

#msno.heatmap(df[nullable_columns], figsize=(18,18))


feature_subset=['Machine', 'SizeOfOptionalHeader', 'Characteristics',
       'MajorLinkerVersion', 'MinorLinkerVersion', 'SizeOfCode',
       'SizeOfInitializedData', 'SizeOfUninitializedData',
       'AddressOfEntryPoint', 'BaseOfCode', 'BaseOfData', 'ImageBase',
       'SectionAlignment', 'FileAlignment', 'MajorOperatingSystemVersion'
       ]

#sns.heatmap(df[feature_subset].corr(method='spearman'),square=True,annot=True,cmap='rainbow_r',vmin=-1,vmax=1)



sel_features=['SizeOfCode','AddressOfEntryPoint','BaseOfData','SectionAlignment','MajorLinkerVersion']

#sns.heatmap(df[sel_features].corr(method='spearman'),square=True,annot=True,cmap='rainbow_r',vmin=-1,vmax=1)
#df['legitimate']



#biivariate analysis
#using the pd.crosstab function to find the percentage of particular attributes having 0 or 1 legitimate value.
rel_size_code_and_legitimate=pd.crosstab(df.SizeOfCode,df.legitimate,normalize='index',margins=True)
AddressOfEntryPoint_and_legitimate=pd.crosstab(df.AddressOfEntryPoint,df.legitimate,normalize='index',margins=True)
BaseOfData_and_legitimate=pd.crosstab(df.BaseOfData,df.legitimate,normalize='index',margins=True)
SectionAlignment_and_legitimate=pd.crosstab(df.SectionAlignment,df.legitimate,normalize='index',margins=True)

#print(rel_size_code_and_legitimate)
#print(AddressOfEntryPoint_and_legitimate[0:5])
#print(BaseOfData_and_legitimate[0:5])
#print(SectionAlignment_and_legitimate[0:5])

plt.figure(figsize=(8,6))

plt.scatter(x=df.legitimate,y=df.BaseOfData)
plt.scatter(x=df.legitimate,y=df.AddressOfEntryPoint)
plt.scatter(x=df.legitimate,y=df.SizeOfCode)
plt.scatter(x=df.legitimate,y=df.SectionAlignment)
plt.scatter(x=df.legitimate,y=df.MajorLinkerVersion)

std_BaseOfData=df.BaseOfData.std()

upper_limit_BaseOfData=df.BaseOfData.mean()+3*std_BaseOfData
lower_limit_BaseOfData=df.BaseOfData.mean()-3*std_BaseOfData

outliers_BaseofData=df[(df.BaseOfData>upper_limit_BaseOfData)|(df.BaseOfData<lower_limit_BaseOfData)]


upper_limit_AddressOfEntryPoint=df.AddressOfEntryPoint.mean()+3*df.AddressOfEntryPoint.std()
lower_limit_AddressOfEntryPoint=df.AddressOfEntryPoint.mean()-3*df.AddressOfEntryPoint.std()

outliers_SizeOfCode=df[(df.AddressOfEntryPoint>upper_limit_AddressOfEntryPoint)|(df.AddressOfEntryPoint<lower_limit_AddressOfEntryPoint)]



upper_limit_SizeOfCode=df.SizeOfCode.mean()+3*df.SizeOfCode.std()
lower_limit_SizeOfCode=df.SizeOfCode.mean()-3*df.SizeOfCode.std()


outliers_AddressOfEntryPoint=df[(df.AddressOfEntryPoint>upper_limit_SizeOfCode)|(df.AddressOfEntryPoint<lower_limit_SizeOfCode)]

upper_limit_SectionAlignment=df.SectionAlignment.mean()+3*df.SectionAlignment.std()
lower_limit_SectionAlignment=df.SectionAlignment.mean()-3*df.SectionAlignment.std()


outliers_SectionAlignment=df[(df.SectionAlignment>upper_limit_SectionAlignment)|(df.SectionAlignment<lower_limit_SectionAlignment)]

upper_limit_MajorLinkerVersion=df.MajorLinkerVersion.mean()+3*df.MajorLinkerVersion.std()
lower_limit_MajorLinkerVersion=df.MajorLinkerVersion.mean()-3*df.MajorLinkerVersion.std()

outliers_MajorLinkerVersion=df[(df.MajorLinkerVersion>upper_limit_MajorLinkerVersion)|(df.MajorLinkerVersion<lower_limit_MajorLinkerVersion)]


#print(len(outliers_BaseofData))
#print(len(outliers_SizeOfCode))
#print(len(outliers_AddressOfEntryPoint))
#print(len(outliers_SectionAlignment))
#print(len(outliers_MajorLinkerVersion))

new_df=df[['SizeOfCode','AddressOfEntryPoint','BaseOfData','SectionAlignment','MajorLinkerVersion']]

new_df=new_df[(new_df.SizeOfCode<upper_limit_SizeOfCode)&(new_df.AddressOfEntryPoint<upper_limit_AddressOfEntryPoint)&
              (new_df.BaseOfData<upper_limit_BaseOfData)&(new_df.SectionAlignment<upper_limit_SectionAlignment)&


              (new_df.SizeOfCode > lower_limit_SizeOfCode)&(new_df.AddressOfEntryPoint > lower_limit_AddressOfEntryPoint)&
              (new_df.BaseOfData > lower_limit_BaseOfData)&(new_df.SectionAlignment > lower_limit_SectionAlignment)
              ]


new_df['zscore_MajorLinkerVersion']=(df.MajorLinkerVersion-df.MajorLinkerVersion.mean())/df.MajorLinkerVersion.std()




#filling the na values with mean value
mean_val=new_df.MajorLinkerVersion.mean()
median_val=new_df.MajorLinkerVersion.median()
mode_val=new_df.MajorLinkerVersion.mode()


new_df['MajorLinkerVersion']=new_df['MajorLinkerVersion'].fillna(mean_val)
new_df['MajorLinkerVersion']=new_df['MajorLinkerVersion'].fillna(median_val)
new_df['MajorLinkerVersion']=new_df['MajorLinkerVersion'].fillna(mode_val)


#creating a new column named MajorLinkerVersion_null where the column contains 1  if the value is missing else 0
new_df['MajorLinkerVersion_null']=np.where(new_df['MajorLinkerVersion'].isnull(),1,0)


print(df.groupby(['legitimate'])['MajorLinkerVersion'].groups)